<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Status Buttons Widget</title>
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <style>
    :root {
      --background: #ffffff;
      --foreground: #0f172a;
      --card: #ffffff;
      --card-foreground: #0f172a;
      --muted: #f1f5f9;
      --muted-foreground: #64748b;
      --border: #e2e8f0;
      --input: #e2e8f0;
      --primary: #0f172a;
      --primary-foreground: #f8fafc;
      --secondary: #f1f5f9;
      --secondary-foreground: #0f172a;
      --accent: #f1f5f9;
      --accent-foreground: #0f172a;
      --ring: #94a3b8;
      --radius: 0.5rem;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
      background: var(--background);
      color: var(--foreground);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #app {
      padding: 16px;
      max-width: 100%;
    }

    .week-nav {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 16px;
      margin-bottom: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      flex-wrap: wrap;
    }

    .week-nav button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--background);
      color: var(--foreground);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .week-nav button:hover {
      background: var(--accent);
      border-color: var(--border);
    }

    .week-nav button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px var(--background), 0 0 0 4px var(--ring);
    }

    .week-nav button:active {
      transform: scale(0.98);
    }

    .week-label {
      font-weight: 600;
      font-size: 14px;
      color: var(--foreground);
      min-width: 160px;
      text-align: center;
      padding: 0 8px;
    }

    .week-status {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }

    .week-status-label {
      font-size: 13px;
      font-weight: 600;
      color: var(--muted-foreground);
    }

    .today-btn {
      background: var(--primary) !important;
      color: var(--primary-foreground) !important;
      border-color: var(--primary) !important;
    }

    .today-btn:hover {
      opacity: 0.9;
      background: var(--primary) !important;
    }

    .records-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .record {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      transition: box-shadow 0.15s ease;
    }

    .record:hover {
      box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    }

    .record-info {
      flex: 1;
      min-width: 0;
    }

    .title {
      font-weight: 500;
      font-size: 14px;
      color: var(--foreground);
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .details {
      margin-top: 4px;
      font-size: 13px;
      color: var(--muted-foreground);
      white-space: pre-wrap;
      overflow-wrap: anywhere;
    }

    .buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .status-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      border: 1px solid transparent;
      border-radius: calc(var(--radius) - 2px);
      background: var(--secondary);
      color: var(--muted-foreground);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .status-btn:hover {
      background: var(--accent);
      color: var(--accent-foreground);
    }

    .status-btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px var(--background), 0 0 0 4px var(--ring);
    }

    .status-btn:active {
      transform: scale(0.97);
    }

    .status-btn.active {
      font-weight: 600;
      box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    }

    .no-records, .config-message {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted-foreground);
      text-align: center;
      padding: 48px 24px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 14px;
    }

    /* Responsive styles */
    @media (max-width: 640px) {
      #app {
        padding: 12px;
      }

      .week-nav {
        padding: 12px;
        gap: 6px;
      }

      .week-nav button {
        padding: 8px 12px;
        font-size: 13px;
      }

      .week-label {
        width: 100%;
        order: -1;
        margin-bottom: 8px;
        font-size: 13px;
        min-width: unset;
      }

      .nav-buttons {
        display: flex;
        gap: 6px;
        width: 100%;
        justify-content: center;
      }

      .record {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
        padding: 14px;
      }

      .title {
        font-size: 15px;
        text-align: left;
      }

      .buttons {
        justify-content: flex-start;
        gap: 8px;
      }

      .status-btn {
        flex: 1;
        min-width: calc(50% - 4px);
        max-width: calc(50% - 4px);
        padding: 10px 12px;
        font-size: 13px;
      }
    }

    @media (max-width: 400px) {
      .week-nav button {
        padding: 6px 10px;
        font-size: 12px;
      }

      .week-label {
        font-size: 12px;
      }

      .status-btn {
        min-width: 100%;
        max-width: 100%;
      }
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      .week-nav button,
      .status-btn {
        min-height: 44px;
      }

      .status-btn {
        padding: 12px 16px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="config-message">Loading...</div>
  </div>

  <script>
    let records = [];
    let choiceStyles = {};
    let tableId = null;
    let statusColumnId = null;
    let statusColumnType = null;
    let currentWeekStart = getWeekStart(new Date());

    function getWeekStart(date) {
      const d = new Date(date);
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      d.setDate(diff);
      d.setHours(0, 0, 0, 0);
      return d;
    }

    function getWeekEnd(weekStart) {
      const end = new Date(weekStart);
      end.setDate(end.getDate() + 6);
      end.setHours(23, 59, 59, 999);
      return end;
    }

    function formatWeekLabel(weekStart) {
      const weekEnd = getWeekEnd(weekStart);
      const opts = { month: 'short', day: 'numeric' };
      const startStr = weekStart.toLocaleDateString('en-US', opts);
      const endStr = weekEnd.toLocaleDateString('en-US', { ...opts, year: 'numeric' });
      return `${startStr} – ${endStr}`;
    }

    function prevWeek() {
      currentWeekStart.setDate(currentWeekStart.getDate() - 7);
      render();
    }

    function nextWeek() {
      currentWeekStart.setDate(currentWeekStart.getDate() + 7);
      render();
    }

    function goToToday() {
      currentWeekStart = getWeekStart(new Date());
      render();
    }

    function isInCurrentWeek(dateValue) {
      if (dateValue === null || dateValue === undefined) return false;
      
      let recordDate;
      if (dateValue instanceof Date) {
        recordDate = dateValue;
      } else if (typeof dateValue === 'number') {
        recordDate = new Date(dateValue * 1000);
      } else if (typeof dateValue === 'string') {
        recordDate = new Date(dateValue);
      } else if (typeof dateValue === 'object' && dateValue.getTime) {
        recordDate = new Date(dateValue.getTime());
      } else {
        return false;
      }
      
      if (isNaN(recordDate.getTime())) return false;
      const weekEnd = getWeekEnd(currentWeekStart);
      return recordDate >= currentWeekStart && recordDate <= weekEnd;
    }

    grist.ready({
      columns: [
        { name: 'Title', title: 'Title', type: 'Text' },
        { name: 'Status', title: 'Status', type: 'Any' },
        { name: 'Options', title: 'Options', type: 'ChoiceList', description: 'Per-row status options' },
        { name: 'Date', title: 'Date', type: 'Date,DateTime', description: 'Date or DateTime column' },
        { name: 'Details', title: 'Details', type: 'Text', optional: true }
      ],
      requiredAccess: 'full'
    });

    grist.onRecords((data, mappings) => {
      records = grist.mapColumnNames(data) || [];
      if (mappings && mappings.Status) {
        statusColumnId = mappings.Status;
        fetchStatusChoices();
      }
      render();
    });

    grist.on('message', (msg) => {
      if (msg.tableId) {
        tableId = msg.tableId;
        if (statusColumnId) {
          fetchStatusChoices();
        }
      }
    });

    async function fetchChoiceStyles(columnId) {
      if (!columnId || !tableId) return null;

      // Try using REST API with access token (works with read/write access)
      try {
        const tokenInfo = await grist.getAccessToken({ readOnly: true });
        const response = await fetch(`${tokenInfo.baseUrl}/tables/${tableId}/columns/${columnId}`, {
          headers: { 'Authorization': `Bearer ${tokenInfo.token}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          const colType = data.type || null;
          let choices = [];
          let styles = {};
          const widgetOptions = data.widgetOptions;
          if (widgetOptions) {
            try {
              const options = typeof widgetOptions === 'string' 
                ? JSON.parse(widgetOptions) 
                : widgetOptions;
              if (options.choices && Array.isArray(options.choices)) {
                choices = options.choices;
                styles = options.choiceOptions || {};
              }
            } catch (e) {
              console.warn('Failed to parse widget options from API:', e);
            }
          }
          return { choices, styles, type: colType };
        }
      } catch (e) {
        console.error('Failed to fetch via API:', e);
      }

      // Fallback to metadata tables (requires full access)
      try {
        const tables = await grist.docApi.fetchTable('_grist_Tables');
        const columns = await grist.docApi.fetchTable('_grist_Tables_column');

        const tableRef = tables.id[tables.tableId.indexOf(tableId)];
        if (!tableRef) return null;

        const colIndex = columns.id.findIndex((id, i) => 
          columns.parentId[i] === tableRef && columns.colId[i] === columnId
        );
        if (colIndex === -1) return null;

        const colType = columns.type[colIndex];
        if (!colType) return null;

        let choices = [];
        let styles = {};
        const widgetOptions = columns.widgetOptions[colIndex];
        if (widgetOptions) {
          try {
            const options = JSON.parse(widgetOptions);
            if (options.choices && Array.isArray(options.choices)) {
              choices = options.choices;
              styles = options.choiceOptions || {};
            }
          } catch (e) {
            console.warn('Failed to parse widget options from metadata:', e);
          }
        }

        return { choices, styles, type: colType };
      } catch (e) {
        console.error('Failed to fetch choice styles:', e);
      }

      return null;
    }

    async function fetchStatusChoices() {
      if (!statusColumnId || !tableId) return;

      // Try to get choices and styles from the main Status column
      const mainResult = await fetchChoiceStyles(statusColumnId);
      
      if (mainResult) {
        statusColumnType = mainResult.type || null;
        const hasStyles = Object.keys(mainResult.styles).length > 0;
        choiceStyles = hasStyles ? mainResult.styles : {};
        render();
      }
    }

    function extractRefId(value) {
      if (value === null || value === undefined) return null;
      if (typeof value === 'number') return value;
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return null;
        const num = Number(trimmed);
        return Number.isNaN(num) ? null : num;
      }
      if (typeof value === 'object') {
        if (value.id !== undefined) return extractRefId(value.id);
        if (value.value !== undefined) return extractRefId(value.value);
      }
      return null;
    }

    function coerceRefListValue(value) {
      if (value === null || value === undefined) return [];
      if (Array.isArray(value)) {
        return value.map(extractRefId).filter(id => typeof id === 'number' && !Number.isNaN(id));
      }
      const id = extractRefId(value);
      return id === null ? [] : [id];
    }

    function coerceRefValue(value) {
      if (value === null || value === undefined) return null;
      if (Array.isArray(value)) {
        const id = extractRefId(value[0]);
        return id === null ? null : id;
      }
      const id = extractRefId(value);
      return id === null ? null : id;
    }

    function coerceStatusValue(value) {
      if (!statusColumnType) return value;
      if (statusColumnType.startsWith('RefList')) return coerceRefListValue(value);
      if (statusColumnType.startsWith('Ref')) return coerceRefValue(value);
      return value;
    }

    async function changeStatus(rowId, newStatus) {
      try {
        const table = await grist.selectedTable;
        await table.update({ id: rowId, fields: { Status: coerceStatusValue(newStatus) } });
      } catch (e) {
        console.error('Failed to update status:', e);
      }
    }

    async function changeWeekStatus(newStatus) {
      try {
        const table = await grist.selectedTable;
        const weekRecords = records.filter(r => isInCurrentWeek(r.Date));
        for (const record of weekRecords) {
          await table.update({ id: record.id, fields: { Status: coerceStatusValue(newStatus) } });
        }
        render();
      } catch (e) {
        console.error('Failed to update week status:', e);
      }
    }

    function normalizeOptionItem(option) {
      if (option === null || option === undefined) return null;
      if (typeof option === 'object') {
        const rawLabel = option.label ?? option.name ?? option.text ?? option.display ?? option.value;
        const rawValue = option.value ?? option.name ?? option.text ?? option.display ?? option.label;
        if (rawLabel === undefined && rawValue === undefined) return null;
        const label = typeof rawLabel === 'string' ? rawLabel.trim() : `${rawLabel}`.trim();
        let value = rawValue;
        if (typeof value === 'string') {
          value = value.trim();
        }
        return { label, value };
      }
      return { label: `${option}`.trim(), value: option };
    }

    function normalizeOptions(value) {
      if (value === null || value === undefined) return [];
      if (Array.isArray(value)) {
        return value.map(normalizeOptionItem).filter(option => option && option.label);
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return [];
        if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
          try {
            const parsed = JSON.parse(trimmed);
            if (Array.isArray(parsed)) {
              return parsed.map(normalizeOptionItem).filter(option => option && option.label);
            }
          } catch (e) {
            console.warn('Failed to parse Options JSON, falling back to commas:', e);
          }
        }
        return trimmed.split(',').map(option => normalizeOptionItem(option)).filter(option => option && option.label);
      }
      return [normalizeOptionItem(value)].filter(option => option && option.label);
    }

    function getOptionKey(option) {
      if (!option) return '';
      const rawValue = option.value !== undefined ? option.value : option.label;
      if (rawValue === undefined) return '';
      if (rawValue instanceof Date) return rawValue.toISOString();
      if (typeof rawValue === 'object') return JSON.stringify(rawValue);
      return `${rawValue}`;
    }

    function getOptionLabel(option) {
      if (!option) return '';
      if (option.label === null || option.label === undefined) return '';
      return `${option.label}`;
    }

    function getChoiceStyle(option) {
      if (!option) return {};
      const valueKey = option.value !== undefined ? `${option.value}` : '';
      const labelKey = option.label !== undefined ? `${option.label}` : '';
      return choiceStyles[valueKey] || choiceStyles[labelKey] || {};
    }

    function areValuesEqual(a, b) {
      if (a === b) return true;
      if (a === null || a === undefined || b === null || b === undefined) return false;
      if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
      return JSON.stringify(a) === JSON.stringify(b);
    }

    function serializeOptionValue(value) {
      if (value === undefined) return 'null';
      if (value instanceof Date) {
        return JSON.stringify({ __type: 'Date', value: value.toISOString() });
      }
      return JSON.stringify(value);
    }

    function parseOptionValue(value) {
      if (!value) return null;
      try {
        const parsed = JSON.parse(value);
        if (parsed && typeof parsed === 'object' && parsed.__type === 'Date') {
          return new Date(parsed.value);
        }
        return parsed;
      } catch (e) {
        return null;
      }
    }

    function encodeHtmlAttribute(value) {
      return `${value}`
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function bindStatusButtons() {
      const app = document.getElementById('app');
      app.onclick = (event) => {
        const button = event.target.closest('button[data-action]');
        if (!button) return;
        const value = parseOptionValue(button.dataset.value);
        if (button.dataset.action === 'week') {
          changeWeekStatus(value);
          return;
        }
        if (button.dataset.action === 'status') {
          const rowId = Number(button.dataset.rowId);
          if (Number.isNaN(rowId)) return;
          changeStatus(rowId, value);
        }
      };
    }

    function getRecordOptions(record) {
      return normalizeOptions(record.Options);
    }

    function getWeekOptions(weekRecords) {
      if (!weekRecords.length) return [];
      const baseOptions = getRecordOptions(weekRecords[0]);
      let intersection = new Set(baseOptions.map(getOptionKey));
      for (const record of weekRecords.slice(1)) {
        const options = new Set(getRecordOptions(record).map(getOptionKey));
        intersection = new Set([...intersection].filter(option => options.has(option)));
        if (intersection.size === 0) break;
      }
      return baseOptions.filter(option => intersection.has(getOptionKey(option)));
    }

    function render() {
      const app = document.getElementById('app');

      const filteredRecords = records.filter(r => isInCurrentWeek(r.Date));
      const weekStatuses = getWeekOptions(filteredRecords);
      const weekStatusButtons = weekStatuses.map(option => {
        const style = getChoiceStyle(option);
        const bgColor = style.fillColor || 'var(--secondary)';
        const textColor = style.textColor || 'var(--muted-foreground)';
        return `
          <button class="status-btn" 
            data-action="week"
            data-value="${encodeHtmlAttribute(serializeOptionValue(option.value))}"
            style="background: ${bgColor}; color: ${textColor};">
            ${escapeHtml(getOptionLabel(option))}
          </button>
        `;
      }).join('');
      const weekStatusControls = weekStatuses.length ? `
        <div class="week-status">
          <span class="week-status-label">Set week:</span>
          ${weekStatusButtons}
        </div>
      ` : '';

      const weekNav = `
        <div class="week-nav">
          <span class="week-label">${formatWeekLabel(currentWeekStart)}</span>
          <div class="nav-buttons">
            <button onclick="prevWeek()">← Prev</button>
            <button class="today-btn" onclick="goToToday()">Today</button>
            <button onclick="nextWeek()">Next →</button>
          </div>
          ${weekStatusControls}
        </div>
      `;

      if (filteredRecords.length === 0) {
        app.innerHTML = weekNav + '<div class="no-records">No records for this week</div>';
        bindStatusButtons();
        return;
      }

      app.innerHTML = weekNav + '<div class="records-container">' + filteredRecords.map(record => {
        const title = record.Title || '(no title)';
        const details = record.Details || '';
        const currentStatus = record.Status;
        const recordOptions = getRecordOptions(record);
        const detailsHtml = details ? `<div class="details">${escapeHtml(details)}</div>` : '';

        return `
          <div class="record">
            <div class="record-info">
              <div class="title">${escapeHtml(title)}</div>
              ${detailsHtml}
            </div>
            <div class="buttons">
              ${recordOptions.map(option => {
                const style = getChoiceStyle(option);
                const isActive = areValuesEqual(option.value, currentStatus);
                const bgColor = isActive ? (style.fillColor || 'var(--primary)') : 'var(--secondary)';
                const textColor = isActive ? (style.textColor || 'var(--primary-foreground)') : 'var(--muted-foreground)';
                const activeClass = isActive ? 'active' : '';
                return `
                  <button class="status-btn ${activeClass}" 
                    data-action="status"
                    data-row-id="${record.id}"
                    data-value="${encodeHtmlAttribute(serializeOptionValue(option.value))}"
                    style="background: ${bgColor}; color: ${textColor};">
                    ${escapeHtml(getOptionLabel(option))}
                  </button>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }).join('') + '</div>';
      bindStatusButtons();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text === null || text === undefined ? '' : `${text}`;
      return div.innerHTML;
    }
  </script>
</body>
</html>
